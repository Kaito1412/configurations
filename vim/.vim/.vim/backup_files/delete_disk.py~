# -*- coding: utf-8 -*-

import argparse
import random
from command.command import Ssh
from command.command_exceptions import CommandError
from command.command_exceptions import RollbackError
from libs.helpers import gen_response
from comfy import config


def delete_disk(recipe):
    class Worker(recipe):
        """
         este worker no va a usar self.get() etc  porque no se conecta
         al hipervisor sino que se conecta a una maquina que recibe
         por configuracion
          - hypervisor (se ignora)
          - vm: virtual machine dict
          - target: disk
          - params: {'new_disk_id': new_disk}
        """
        KEY_CONFIG = 'DELETE_DISK_TARGETS'

        def start(self, *args, **kwargs):
            """ start """
            target_ip = random.choice(config.GIGAS[self.KEY_CONFIG])
            if target_ip is None:
                raise Exception("Missing {0} "
                                "key in config".format(self.KEY_CONFIG))

            datastore, disk = _get_params(**kwargs)

            _delete_disk(
                remote_machine=target_ip,
                datastore=datastore,
                disk=disk,
            )
            return gen_response()

    return Worker


def _get_params(**kwargs):

    disk = kwargs.get('target')
    disk_identifier = kwargs.get('target').get('identifier')
    data_store_identifier = disk.get('data_store').get('identifier')

    return data_store_identifier, disk_identifier


def _delete_disk(remote_machine, datastore, disk):
    """
    delete a disk
     - remote_machine what host to connect with to delete disk
     - datastore: datastore identifier
     - disk: disk identifier
    """
    with Ssh(remote_machine, username="root") as ssh:

        dd_log_path = config.GIGAS["DELETE_DISK_LOG_PATH"]
        # If the log directory doesn't exist, create it
        ssh.run("[ -d {log_path} ] || mkdir -p {log_path}".format(
            log_path=dd_log_path
        ))

        # activate volume
        cmd_activate_volume = "lvchange -a y /dev/{datastore}/{disk}".format(
            datastore=datastore,
            disk=disk, )
        ssh.run(cmd_activate_volume)

        cmd_deactivate_volume = "lvchange -a n /dev/{datastore}/{disk}".format(
            datastore=datastore,
            disk=disk, )
        ssh.rollback(cmd_deactivate_volume)

        # write zeros
        cmd_write_zeros = ("dd if=/dev/zero bs=1024k | "
                           "throttle -M 10 | "
                           "pv -f 2>{log_path}/{disk}.log | "
                           "dd of=/dev/{datastore}/{disk} bs=16k".format(
                               datastore=datastore,
                               disk=disk,
                               log_path=dd_log_path,
                           ))
        ssh.run(cmd_write_zeros, ignore_errors=True)

        ssh.run(cmd_deactivate_volume)  # if error, don't delete disk

        cmd_remove_volume = "lvremove -f /dev/{datastore}/{disk}".format(
            datastore=datastore,
            disk=disk, )
        ssh.run(cmd_remove_volume)  # if error, don't delete disk

        return True


def parse_args():
    """ parse arguments """
    my_parser = argparse.ArgumentParser(description='Disk deletion.')

    my_parser.add_argument("--datastore", help="datastore")
    my_parser.add_argument("--disk", help="disk")
    args = my_parser.parse_args()
    data = (args.datastore, args.disk)
    if None in data:
        exit("Faltan datos: %s" % [k
                                   for k in args.__dict__
                                   if args.__dict__[k] is None])
    return data


if __name__ == "__main__":
    target_ip = random.choice(config.GIGAS['DELETE_DISK_TARGETS'])
    if target_ip is None:
        raise Exception("Missing DELETE_DISK_TARGETS key in config")
    datastore, disk = parse_args()
    try:
        _delete_disk(target_ip, datastore, disk)
    except (CommandError, RollbackError):
        raise

    print("Operation succeeded")
