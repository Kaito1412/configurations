from lxml import etree

import cronbase  # NOQA
from kayako.models import Kayako
from professional_services.models import (PSIncidence,
                                          PSIncidenceTemporal,
                                          PSAccount,
                                          PSClient,
                                          ProfessionalService)
from onapp.models import VirtualMachine
import logging
from itertools import ifilter
from django.db import transaction
from datetime import datetime
from django.conf import settings
from django.db import connection

logging.basicConfig(level=logging.DEBUG)

PS_TAG_PREFIX = settings.PS_TAG_PREFIX


class NoVMFromTag(Exception):
    pass


class NoAddonFromTag(Exception):
    pass


class XMLParseError(Exception):
    pass


def clear_table():
    cursor = connection.cursor()
    cursor.execute("TRUNCATE TABLE `{0}`".format(
        PSIncidenceTemporal._meta.db_table))


def gen_ticket_dictionary(ticket_etree):
    ticket = dict([(prop.tag, prop.text) for prop in ticket_etree])
    ticket.update(ticket_etree.items())
    return ticket


def _k_call(url, data=None, verb='GET'):
    """
    Call callaco and get it's tickets parsed into dictionaries
    """
    retry = 3
    while retry > 0:
        try:
            k_server = Kayako.objects.order_by('id')[0]
        except Kayako.DoesNotExist:
            logging.exception("No kayako configured")
            raise

        xml_response = k_server.send(url, data, verb)
        logging.debug("url: %s, data: %s, verb: %s",
                      url, data, verb)
        try:
            parser = etree.XMLParser(recover=False,
                                     encoding='utf8',
                                     ns_clean=True)
            xml_tree = etree.fromstring(xml_response, parser)
        except etree.XMLSyntaxError as e:
            retry -= 1
            logging.debug("Retrying url due to an invalid xml: %s", e)
        else:
            break
    if not retry:
        raise XMLParseError("Kayako sent three consecutive invalid responses")

    logging.debug("nodes: %s", len(xml_tree) if xml_tree else 0)
    return [gen_ticket_dictionary(t) for t in xml_tree]


def filter_prof_services(ticket):
    """
    Remove all callaco tickets without professional_services tag.
    """
    try:
        return ticket['tags'] and PS_TAG_PREFIX in ticket['tags']
    except:
        return False


def get_kayako_incidences_per_host(host):
    """
    Get all the callaco Professional services incidences.
    """
    return _k_call("/Tickets/TicketSearch/",
                   {"query": "{0}{1}".format(PS_TAG_PREFIX, host),
                    "tags": 1},
                   "POST")


def get_kayako_page(page_no=0):
    """
    get next group of 200 tickets
    """
    ANY = -1
    SIZE = 20
    return _k_call(
        "/Tickets/Ticket/ListAll/{dept}/{status}/"
        "{owner}/{user}/{count}/{since}/{order_by}/{sort}".format(
            dept=",".join(map(str, settings.PS_DEPT_LIST)),
            status=",".join(map(str, settings.PS_STATUS_LIST)),
            owner=ANY,
            user=ANY,
            count=SIZE,
            since=page_no*SIZE,
            order_by="lastactivity",
            sort="DESC"))


def gen_noop(return_value):
    def noop(*args, **kwargs):
        return return_value
    return noop


class KayakoIncidenceIterator(object):
    """
    Iterator that will get the next batch of items from kayako
    """
    class MustStopIteration(Exception):
        """
        skip the loop and make sure it stops
        """
        pass

    def __init__(self, filter_fun=None,
                 stop_function=None,
                 side_effects_fun=None):
        super(KayakoIncidenceIterator, self).__init__()
        noop_true = gen_noop(True)
        self.filter_fun = filter_fun if filter_fun else noop_true
        self.side_effects_fun = (side_effects_fun if side_effects_fun
                                 else noop_true)
        self.stop_function = (stop_function if stop_function
                              else gen_noop(False))
        self.page = 0
        self.last_call = iter([])
        self.keep_calling = True

    def _get_next_batch(self):
        if not self.keep_calling:
            logging.debug("Already stopped")
            raise self.MustStopIteration()

        new_page = get_kayako_page(self.page)
        self.page += 1
        if not new_page or not len(new_page):
            logging.debug("kayako response is empty")
            raise self.MustStopIteration()
        else:
            self.side_effects_fun(new_page)
            self.last_call = ifilter(self.filter_fun, new_page)

    def __iter__(self):
        return self

    def next(self):
        if not self.keep_calling:
            logging.debug("Can't continue")
            raise StopIteration
        incidence = False
        try:
            while not incidence:
                try:
                    incidence = next(self.last_call)
                except (TypeError, StopIteration):
                    self._get_next_batch()  # recharge the list and ask again
        except self.MustStopIteration:
            self.keep_calling = False
            raise StopIteration

        if not self.stop_function(incidence):
            return incidence
        else:
            self.keep_calling = False
            raise StopIteration

    def __next__(self):
        """
        Compatibilidad futura
        """
        return self.next()


def keep_alive_transaction():
    logging.debug("trying to keep alive MySQL! ")
    sp = transaction.savepoint()
    transaction.savepoint_commit(sp)


def get_kayako_incidences_until(ticket_id, keep_transaction=False):
    """
    Get all the callaco Professional services incidences since a given ticket
    """
    if keep_transaction:
        side_effect = lambda x: keep_alive_transaction()
    else:
        side_effect = None
    return KayakoIncidenceIterator(filter_prof_services,
                                   lambda x: x['id'] == ticket_id,
                                   side_effect)


def get_virtual_machine_from_tags(tags):
    try:
        filtered_tags = [t.split("_", 1)[-1]
                         for t in tags.split()
                         if t.lower().startswith(PS_TAG_PREFIX)]
        vm_id = int(filtered_tags[0])
    except (IndexError, TypeError):
        logging.exception("VM couldn't be gathered from the ticket's tag")
        raise NoVMFromTag()

    try:
        return VirtualMachine.objects.get(vm_id=vm_id)
    except VirtualMachine.DoesNotExist:
        logging.exception("VM %s wasn't found on the DB", vm_id)
        raise NoVMFromTag()


def get_addon_from_tags(tags):
    try:
        filtered_tags = [t.split("_", 1)[-1]
                         for t in tags.split()
                         if t.lower().startswith(PS_TAG_PREFIX)]
        addon_id = int(filtered_tags[0])
        return ProfessionalService.objects.get(pk=addon_id)
    except (IndexError, TypeError):
        logging.exception("VM couldn't be gathered from the ticket's tag")
        raise NoAddonFromTag()
    except ProfessionalService.DoesNotExist:
        logging.exception("Addon %s wasn't found on DB", addon_id)
        raise NoAddonFromTag()


def migrate_new_tickets():
    for temp in PSIncidenceTemporal.objects.iterator():
        inc = PSIncidence()
        inc.kayako_id = temp.kayako_id
        inc.created_at = temp.created_at
        inc.account = temp.account
        inc.client = temp.client
        inc.addon = temp.addon
        inc.ticket_mask = temp.ticket_mask
        inc.subject = temp.subject
        inc.save()

# for account in PSAccount.objects:
#     #get account's hosts
#     #get kayako incidences per host
#     #add incidences into table
#     pass


def update_incidence_database():
    try:
        last_incidence = (PSIncidence.objects
                          .order_by("-kayako_id")[0].kayako_id)
    except (PSIncidence.DoesNotExist, IndexError):
        last_incidence = 0
    logging.info("getting new incidences until %s", last_incidence)
    try:
        new_batch = get_kayako_incidences_until(last_incidence)
    except Exception as e:
        logging.exception(e)
        logging.error("Won't process anything due to an "
                      "error retrieving the list from Kayako: {0}"
                      .format(e))
        raise
    else:
        logging.info("Got all the kayako tickets, processing list")
    # remove any previous runs
    clear_table()
    try:
        result = {
            "created": 0,
            "updated": 0,
            "ignored": 0}

        for ticket in new_batch:
            try:
                host_addon = get_addon_from_tags(ticket['tags'])
            except NoAddonFromTag:
                logging.error("ticket %s ignored due to bad tag",
                              ticket['id'])
                result["ignored"] += 1
                continue
            try:
                inc = PSIncidence.objects.get(pk=ticket['id'])
            except PSIncidence.DoesNotExist:
                account = host_addon.account_id
                logging.debug("account %s client %s",
                              account.id,
                              account.client_id.id)
                PSIncidenceTemporal(kayako_id=ticket['id'],
                                    created_at=datetime.fromtimestamp(
                                        int(ticket['creationtime'])),
                                    addon=host_addon,
                                    account=PSAccount.objects.get(
                                        pk=account.id),
                                    client=PSClient.objects.get(
                                        pk=account.client_id.id),
                                    ticket_mask=ticket['displayid'],
                                    subject=ticket['subject']).save()
                result["created"] += 1
                logging.info("Created ticket %s", ticket['id'])
            else:
                inc.created_at = datetime.fromtimestamp(
                    int(ticket['creationtime']))
                inc.addon = host_addon
                inc.ticket_mask = ticket['displayid']
                inc.subject = ticket['subject']
                inc.save()
                result["updated"] += 1
                logging.info("Updated ticket %s", ticket['id'])
    except Exception as e:
        logging.exception(e)
        logging.error("Captured an error, probably due to kayako failing, "
                      "all incidences created have been rolled back")
        return {"created": 0,
                "updated": 0,
                "ignored": 0}
    else:
        migrate_new_tickets()
    return result

if __name__ == '__main__':
    res = update_incidence_database()
    logging.info("%(created)s created, %(ignored)s ignored, "
                 "%(updated)s updated", res)
