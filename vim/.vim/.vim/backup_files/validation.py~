# -*- coding: utf-8 -*-
import re
from ipaddr import IPAddress
from copy import copy
import datetime


#metaprogramacion FTW!
def str_validator_generator(max_size=255, min_size=0, valid_expr=r"^[\w@\-\.]+$", to_lower=False, is_like=False):
    '''
    generates a function that only accepts a string as a parameter
    validator of strings based on the following parameters:
    max_size: maximum number of characters
    min_size: minimum number of characters
    valid_expr: regular expresion with the valid characters. Default: ^[\w@\-]+$
    to_lower: convert the valid result to a lowercase string
    '''
    valid = None
    if valid_expr is not None:
        valid = re.compile(valid_expr)

    #generate function with the parameters
    def string_val(value):

        #check it can be a string:
        if value is None or len(value) != 1:
            raise ValueError
        else:
            value = str(value[0])  # tornado passes parameters in lists

        #check size
        u_value = unicode(value, 'UTF-8')
        if len(u_value) < min_size or len(u_value) > max_size:
            raise ValueError('param must have between {min} and {max} characters'.format(min=min_size, max=max_size))
        elif valid is not None:  # validate it with regexp
            o = valid.match(value)
            if o is None:
                raise ValueError('param does not validate')
            value = getattr(o, 'string', None)

        if to_lower and value:
            # if value exists and it isn't empty try to lower if to_lower
            value = value.lower()

        if is_like:
            value = "%{value}%".format(value=value)

        return value

    #returns a function that receives only one parameter
    return string_val


def integer_validator_generator(nullable=False):
    def int_validator(value):
        '''
        checks for an integer
        '''
        if value is None:
            raise ValueError
        value_list = copy(value)
        if len(value_list) == 0:
            raise ValueError('integer expected')
        for value_pos, value in enumerate(value_list):
            if value == u'null' and nullable is True:
                value_list[value_pos] = None
            elif not isinstance(value, (int, basestring, )):
                raise ValueError('integer expected')
            else:
                try:
                    value_to_int = int(value)
                    value_list[value_pos] = value_to_int
                except ValueError:
                    raise ValueError('integer expected')
        if len(value_list) == 1:
            return value_list[0]
        else:
            return value_list
    return int_validator


def integer_validator(value):
    return integer_validator_generator(nullable=False)(value)


def integer_range_validator_generator(min_val=None, max_val=None):
    '''
    given a min and a max, generates a function checker
    '''
    def int_val(value):
        value_list = value
        for value_pos, value in enumerate(value_list):
            try:
                res = int(value)
                value_list[value_pos] = res
            except ValueError:
                raise ValueError('integer expected')
            if min_val is not None and res < min_val:
                raise ValueError("value out of range")
            elif max_val is not None and res > max_val:
                raise ValueError("value out of range")

        if len(value_list) == 1:
            return value_list[0]
        else:
            return value_list
    return int_val


def boolean_translator_validator(value):
    '''
    lowercase only, translates
    '''
    if value is None or len(value) != 1:
        raise ValueError
    value = str(value[0])  # tornado passes parameters in lists
    if value.lower() == "true" or value == "1":
        return 1
    elif value.lower() == "false" or value == "0":
        return 0
    else:
        raise ValueError("boolean value expected")


def enum_validator_generator(options):
    '''
    given a set of options, generate a function to check if it matchs
    '''
    set_options = set(options)

    def enum_validate(value):
        if value is None or len(value) != 1:
            raise ValueError()
        value = value[0]
        if value == u'null':
            value = None
        if value in set_options:
            return value
        raise ValueError("value not in set of values expected")
    return enum_validate


def multi_enum_validator_generator(options):
    """
    Same as above but accepts multiple values
    """
    set_options = set(options)

    def multi_enum_validate(values):
        if values is None:
            raise ValueError
        values = [x if unicode(x) != u'null' else None for x in values]
        set_values = set(values)
        if set_values.issubset(set_options):
            return True
        else:
            raise ValueError("values not in set of values expected")

    return multi_enum_validate


def and_generator(fun1, fun2):
    '''
    given 2 validator functions, returns the result of fun2 if fun1 is not None
    '''
    return lambda x: fun1(x) and fun2(x)


def or_generator(fun1, fun2):
    '''
    given 2 validator functions, returns the result of fun2 if fun1 is None
    '''
    return lambda x: fun1(x) or fun2(x)


def address_to_integer(value):
    address_validator = str_validator_generator(max_size=15, min_size=6, valid_expr=r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
    val = address_validator(value)
    ip = IPAddress(val)
    try:
        return int(ip)
    except ValueError:
        raise ValueError("invalid ip")


def timedelta_validator(value):
    """
    returns a timedelta from a expresion
    - examples: 6days
    """
    if not value.endswith('days'):
        raise ValueError("invalid date range")
    value = value.replace('days', '')
    try:
        number = int(value)
    except ValueError:
        raise ValueError("invalid date range")

    return datetime.timedelta(days=number)


def datetime_validator_generator():
    return str_validator_generator(max_size=19, min_size=19, valid_expr=r"^\d{4}(\-\d{2}){2} \d{2}(:\d{2}){2}$")


def ip_address_validator(values):
    if values is None:
        raise ValueError
    for value in values:
        str_validator_generator(max_size=15, min_size=1, valid_expr=r"^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|\*)$")([value])

    if len(values) == 1:
        return values[0]
    else:
        return values


def port_validator(values):
    return integer_range_validator_generator(1, 65535)(values)


def name_validator(value):
    v = str_validator_generator(
        max_size=50,
        min_size=1,
        valid_expr=r"^[A-ZÑÁÉÍÓÚÀÈÌÒÙa-zñáéíúóàèìòùñ\- ]*$")
    return v(value)


def label_validator(value):
    v = str_validator_generator(max_size=255, min_size=2, valid_expr=r"^[a-zA-Z áéíóúÁÉÍÓÚÑàèìòùÀÈÌÒÙñäëïöüÄËÏÖÜç\.\-0-9]+$")
    return v(value)


def email_validator(value):
    value = value[0]
    u_value = unicode(value, 'utf-8')
    if len(u_value) < 6 or len(u_value) > 255:
        raise ValueError('Param size between 6 and 255 characters')
    characters = r'ñçáéíóúàèìòùâêîôûäëïöüÑÇÁÉÍÓÚÀÈÌÒÙÂÊÎÔÛÄËÏÖÜ'
    regex = r''.join((r'^[\w\.\+', characters, r'\-]+@([\w\-',
                     characters, r']+\.)+\w{2,3}$'))
    if value is None or not re.match(regex, value):
        raise ValueError
    return value


def hostname_validator(value):
    value = value[0]
    if value is None or len(value) > 255:
        raise ValueError
    hostname = r'^[a-zA-Z][a-zA-Z0-9]*(\-[a-zA-Z0-9]+)*'
    domain = r'(\.[a-zA-Z0-9]+(\-[a-zA-Z0-9]+)*)*$'
    regex = re.compile(r''.join((hostname, domain)))
    if not regex.match(value):
        raise ValueError('param does not validate')
    # Check if the node has 64 characters.
    for node in value.split('.'):
        if len(node) > 64:
            raise ValueError('param does not validate')
    return value


def login_validator(value):
    regexp = r"^[\wáéíóúÁÉÍÓÚÑÇàèìòùÀÈÌÒÙñäëïöüÄËÏÖÜç\.\-\+@\?!#%&\$=<>]+$"
    v = str_validator_generator(max_size=40, min_size=6,
                                valid_expr=regexp,
                                to_lower=True)
    return v(value)
