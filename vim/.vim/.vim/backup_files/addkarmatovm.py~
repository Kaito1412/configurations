# -*- coding: utf-8 -*-

import cronbase  # noqa
from accounts.models import Account
from apps.models import OnApp, Server
from clients.models import ClientExtraDetail
from sqlalchemy.orm.exc import StaleDataError
import logging


def process_app(app, server_id):
    onapp_db = app.get_db()
    for vm in onapp_db.virtual_machines.all():
        failed = True
        try:
            # If there's an error we can't access the `vm` object but we want
            # to include the VM ID in the error message
            vm_id = vm.id
            process_vm(vm, server_id, onapp_db)
        except StaleDataError:
            logging.exception("Error al guardar los cambios de la VM "
                              "#{vm_id!s} del servidor #{server_id!s}: "
                              "probablemente la VM haya sido eliminada "
                              "mientras se actualizada".format(
                                  vm_id=vm_id, server_id=server_id
                              ))
        except Account.DoesNotExist:
            logging.error("El account de la VM #{vm_id!s} del servidor "
                          "#{server_id!s} no existe".format(
                              vm_id=vm_id, server_id=server_id
                          ))
        except ClientExtraDetail.DoesNotExist:
            logging.error("El extra details del cliente de la VM #{vm_id!s} "
                          "del servidor #{server_id!s} no existe".format(
                              vm_id=vm_id, server_id=server_id
                          ))
        except Exception:
            logging.exception("Error desconocido al procesar la VM #{vm_id!s} "
                              "en el servidor #{server_id:d}".format(
                                  vm_id=vm_id, server_id=server_id
                              ))
        else:
            failed = False
            onapp_db.session.commit()

        if failed:
            onapp_db.session.rollback()

    onapp_db.session.remove()
    onapp_db.session.close()


def process_vm(vm, server_id, onapp_db):
    '''
    This method is *not* responsible of the errors than can happened.
    His errors must be controlled by its caller.
    '''
    vm_id = vm.id
    onapp_user = onapp_db.users.filter(
        onapp_db.users.id == vm.user_id
    ).first()

    if onapp_user is None or onapp_user.login == 'admin':
        return

    print u"Procesando cliente de OnApp %s ...\n" % onapp_user.login,

    karma = Account.objects.get(
        username=onapp_user.login,
        server_id=server_id,
        status=['Active', 'Suspend']
    ).client_id.clientextradetail.karma

    admin_note = [] if vm.admin_note is None else vm.admin_note.split(',')
    new_admin_note = [n for n in admin_note if 'karma=' not in n]

    if karma is not None:
        new_admin_note.append('karma=%s' % karma)

    new_admin_note = ','.join(new_admin_note)
    vm.admin_note = new_admin_note

    onapp_db.flush()

    print("Nueva admin note de VM {vm_id!s} es '{admin_note!s}'\n".format(
        vm_id=vm_id, admin_note=new_admin_note
    ))


for app in OnApp.objects.iterator():
    try:
        server_id = app.server.id
        process_app(app, server_id)
    except Server.DoesNotExist:
        logging.exception("Parece que alguna app tiene configurado "
                          "un server no v√°lido")
        continue
    except Exception as err:
        logging.exception("Error al procesar el servidor #{server_id!s}"
                          .format(server_id=server_id)
                          )
        continue
    print("Servidor #{server_id!s} procesado correctamente\n".format(
          server_id=server_id
          ))
