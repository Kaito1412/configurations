# -*- coding: utf-8 -*-
import logging
import datetime
from lxml import etree
import MySQLdb as Database

from django.db import models
from django.core import urlresolvers
from django.utils.encoding import smart_str
from django.core.validators import ValidationError
from django.contrib.auth.models import User
from django.core.mail import send_mail
from warnings import filterwarnings

from kayako.models import Kayako
from clients.models import Client
from plesk.models import Plesk
from email_template.utils import get_email_template
from invoices.models import Invoice
from modules.models import ModuleConfig
from products.models import Product
from licenses.plesk_utils import get_plesk_version
from licenses.utils import get_lic_environment
from idera.models import LicensePool as IderaLicensePool


class Order(models.Model):
    """
    Orders by HB. Normally there are three kinds of orders, services,
    accounts and domains
    """
    STATUS = (('Pending', 'Pending'), ('Active', 'Active'),
              ('Cancelled', 'Cancelled'), ('Fraud', 'Fraud'),
              ('CloudSales', 'CloudSales'))

    number = models.IntegerField(max_length=11)
    payment_module = models.ForeignKey(
        ModuleConfig,
        db_column='payment_module',
        limit_choices_to={'type_field': 'Payment', 'active': 1},
        null=True,
    )
    client_id = models.ForeignKey(Client, db_column='client_id', null=True)
    invoice_id = models.ForeignKey(Invoice, db_column='invoice_id', null=True)
    total = models.FloatField()
    date_created = models.DateField()
    status = models.CharField(max_length=20, choices=STATUS, verbose_name='order status')
    order_ip = models.IPAddressField()
    notes = models.CharField(max_length=255)
    metadata = models.TextField()

    class Meta:
        permissions = (("export_order", "Can export"),)
        db_table = 'hb_orders'
        ordering = ['-id']

    def __unicode__(self):
        return unicode(self.id)


    def client_country(self):
        return self.client_id.country()

    def invoice_status(self):
        invoice_status = self.invoice_id.status
        if invoice_status == 'Paid':
            color = 'limegreen'
        elif invoice_status == 'Unpaid':
            color = 'red'
        elif invoice_status == 'Cancelled':
            color = 'grey'
        else:
            color = 'black'

        return '<span style="color: %s">%s</span>' % (color, self.invoice_id.status)
    invoice_status.allow_tags = True
    invoice_status.admin_order_field = 'invoice_id__status'

    def account_status(self):
        try:
            account_statuses = set([a.status
                                    for a in self.account_set.iterator()])
            if len(account_statuses) == 1:
                account_status = account_statuses.pop()
            elif len(account_statuses) > 1:
                account_status = ('Pending'
                                  if 'Pending' in account_statuses
                                  else account_statuses.pop())
            else:
                return

        except Exception as e:
            account_status = str(e)

        if account_status == 'Active':
            color = 'limegreen'
        elif account_status == 'Pending':
            color = 'red'
        elif account_status == 'Cancelled':
            color = 'grey'
        else:
            color = 'black'

        return '<span style="color: %s">%s</span>' % (color, account_status)
    account_status.allow_tags = True
    account_status.admin_order_field = 'account__status'

    def order_status(self):

        if self.status == 'Active':
            color = 'limegreen'
        elif self.status == 'Pending':
            color = 'red'
        elif self.status == 'Cancelled':
            color = 'grey'
        else:
            color = 'black'

        return '<span style="color: %s">%s</span>' % (color, self.status)
    order_status.allow_tags = True
    order_status.admin_order_field = 'status'

    def product_name(self):
        product_name_list = []
        
        for acc in self.account_set.all():
            if "Licencias" in acc.product_id.category_id.name:
                product_name_list.append(acc.get_complete_product())
            else:
                product_name_list.append(unicode(acc.product_id))
        else:
            try:
                for item in self.invoice_id.get_items():
                    product_name_list.append(item.description)
            except Invoice.DoesNotExist:
                pass
        product_name = u', '.join(product_name_list)
        return product_name or None

    def is_idera_upgrade(self):
        try:
            return ('Backup' in self.accountaddon_set.get().name)

        except:
            return False

    # Admin links
    def invoice_link(self):
        change_url = urlresolvers.reverse('admin:invoices_invoice_change',
                                          args=(self.invoice_id.id,))

        return '<a href="%s">%s</a>' % (change_url, self.invoice_id.id)
    invoice_link.allow_tags = True

    def client_link(self):
        change_url = urlresolvers.reverse('admin:clients_client_change',
                                          args=(self.client_id.id,))

        return '<a href="%s">%s</a>' % (change_url, self.client_id)
    client_link.allow_tags = True

    def licenses(self):
        license_accounts = self.account_set.filter(
            models.Q(license__isnull=False) |
            models.Q(product_id__category_id__name__icontains='licencia'))

        licenses_list = []
        pending_licenses = False

        for license_account in license_accounts:
            license = (license_account.license_set.get()
                       if license_account.license_set.exists()
                       else None)
            if license:
                if license.status == "Active":
                    licenses_list.append("<strong>{0}</strong>"
                                         .format(license.license_key))
                elif license.status == "Cancelled":
                    licenses_list.append("<strong>{0} Cancelled</strong>"
                                         .format(license.license_key))
                elif license.status == 'Created':
                    pending_licenses = True

                else:
                    licenses_list.append("{0} {1}"
                                         .format(license.license_key,
                                                 license.status))
            else:
                if license_account.get_license_type():
                    try:
                        pending_licenses = self.invoice_id.status == 'Paid'
                    except Invoice.DoesNotExist:
                        pending_licenses = True

        if pending_licenses:
            change_url = "#send_license-" + str(self.client_id.id)
            licenses_list.append(
                '<a href="%s" class="license_link" >%s</a>'
                '<label class="lic-info"></label>' % (
                    change_url,
                    "Enviar licencia/s pendiente/s"))

        return '<br />'.join(licenses_list)
    licenses.allow_tags = True

    def license_key(self):
        if self.is_license():
            orderlicenses = self.orderlicense_set.all()
            return orderlicenses[0].license_key

        else:
            return ''

    def upgrade_license(self):
        try:
            accadd = self.accountaddon_set.get()

        except self.accountaddon_set.model.DoesNotExist:
            logging.error('Order %s is not an addon account' % self.id)
            return False

        if self.status != 'Pending':
            logging.error('Order %s is %s' % (self.id, self.status))
            return False

        try:
            license_key = self.accountaddon_set.get().account_id.order_id.orderlicense_set.get().license_key

        except:
            logging.error('Order %s, license not found' % self.id)
            return False

        key = IderaLicensePool.objects.filter(
                    enabled=True,
                    server__environ=get_lic_environment()
                ).latest('id').upgrade_license(license_key)

        if key is not None:
            client = self.client_id.clientdetail
            kayako = Kayako.objects.all()[0]

            ticket_status_id = 14
            department_id = 32
            ticket_type_id = 4
            ticket_priority_id = 2

            ticket = kayako.send_staff_ticket('license:idera_upgrade', client,
                    ticket_status_id=ticket_status_id, department_id=department_id,
                    ticket_type_id=ticket_type_id, ticket_priority_id=ticket_priority_id,
                    content_params={"firstname": client.firstname, "license": license_key,
                        "virtual_servers": key['Virtual Servers']})

            #if ticket is not None:
            #    send_mail()

            self.status = 'Active'
            self.save()

            accadd = self.accountaddon_set.get()
            accadd.status = 'Active'
            accadd.save()

            return True

        else:
            return False

    def send_license(self, license, version=None):
        """
        envia la licencia
        """
        try:
            account = self.account_set.all()[0]
        except IndexError:
            logging.error("Fallo al tomar los datos del account en send_license")
            return "Fallo al tomar los datos del account"

        resp_text = "Result: "
        product_obj = account.product_id
        product_complete = account.get_complete_product()
        client = self.client_id.clientdetail

        # Buscamos una licencia ya creada con ese order
        # La encontraremos solo en caso de que anteriormente fallara el envio a kayako
        try:
            order_license = self.orderlicense_set.get(
                product_id=product_obj,
                status__in=['Created', 'Active'])
        except self.orderlicense_set.model.DoesNotExist:
            order_license = None

        # Si ya está activa salimos
        if order_license and order_license.status == 'Active':
            resp_text = "Previously Active License: " + order_license.license_key
            license_key = order_license.license_key
            return resp_text

        if order_license and order_license.status == 'Created' and 'Backup' in product_complete:
            license_type = "Idera"
            license_key = order_license.license_key
            logging.info("retrieved previously created idera Key")

        elif 'Backup' in product_complete:
            try:
                key = IderaLicensePool.objects.filter(
                    enabled=True,
                    server__environ=get_lic_environment()
                ).latest('id').create_license()
            except IderaLicensePool.DoesNotExist:
                resp_text += 'Idera license pool not found'
                return resp_text

            license_type = "Idera"
            license_key = key['ID']
            logging.info("retrieved new idera Key")

        elif order_license and order_license.status == 'Created' and "Plesk" in product_complete:
            # RetrieveKey
            plesk = Plesk.objects.get(environ=get_lic_environment())
            key = plesk.retrieveKey(key=order_license.license_key)
            if not key['key']:
                logging.error("error retrieving previously created Plesk Key")
                return "License error"
            license_type = "Plesk"
            license_key = key['license']
            logging.info("retrieves previously created Plesk Key")

        elif "Plesk" in product_complete:
            windows_keytype = False
            if 'Windows' in product_complete:
                windows_keytype = True
            plesk = Plesk.objects.get(environ=get_lic_environment())
            key = plesk.retrieveKey(
                license_type=get_plesk_version(self),
                doms=license,
                windows=windows_keytype
            )
            if not key['key']:
                logging.error("error retrieving Plesk Key")
                return "License error"
            license_type = "Plesk"
            license_key = key['license']
            logging.info("retrieves Key Plesk")

        elif order_license and order_license.status == 'Created' and "Windows" in product_complete:
            key = order_license.license_key
            license_type = "Windows"
            license_key = order_license.license_key
            logging.info("retrieves previously created Win Key")

        elif "Windows" in product_complete:
            logging.info("retrieves Key Windows")
            license_type = "Windows"
            try:
                license_filter = license.split("_")

                if len(license_filter) == 1:
                    winlicense = WinLicense.objects.filter(license_type__icontains=license_filter[0])[0]
                elif len(license_filter) == 2:
                    winlicense = WinLicense.objects.filter(license_type__icontains=license_filter[0]).filter(license_type__icontains=license_filter[1])[0]

            except IndexError:
                logging.error("El tipo de licencia no existe")
                resp_text += "Ese tipo de licencia no existe"
                return resp_text
            key = winlicense.key
            license_key = winlicense.key
            winlicense.count += 1
            winlicense.save()

        else:
            logging.error("License {0} type is unknown and will be ignored".format(product_complete))
            return ''

        # Si no tenemos ya orderlicense la añadimos como "Created"
        if not order_license:
            self.orderlicense_set.create(
                product_id=product_obj,
                license_key=license_key,
                license_type=license_type,
                status='Created')
            #order_license = OrderLicense(
            #    order_id=self,
            #    product_id=product_obj,
            #    license_key=license_key,
            #    license_type=license_type,
            #    status='Created')
            order_license.save()

        #Get existing users
        kayako = Kayako.objects.all()[0]
        found = kayako.get_user(email=client.id.email)
        logging.error("user check")

        #Check if exists
        if found:
            logging.error("Inside user exists")
            resp_text += "El usuario ya existia"
        else:
            logging.error("Inside create user")
            resp_text += "El usuario no existia"
            values = kayako.create_user_by_client_id(self.client_id.id)
            try:
                user_values = etree.fromstring(values)
            except etree.XMLSyntaxError, e:
                msg = "Error al crear el usuario %s: %s" % (client.id.email, values)
                logging.error(msg)
                resp_text += msg
                send_mail("Fallo al crear usuario %s en Kayako" % (client.id.email),
                          resp_text, "gigas@gigas.com",
                          ["devs@gigas.com", "javier.navarro@gigas.com", "root@gigas.com"])
                return resp_text
            found = user_values.find("user/id").text

        logging.error("User check passed")

        logging.info("ckeck staff")

        #License sent TODO Provisional
        # El status id "4", en dev tiene que ser "2" sino peta
        if "Idera" in license_type:
            logging.error("Enters send Idera Mail")
            mail = get_email_template('license:idera', client.id)
            if mail is None:
                logging.error("Template license:idera not found")
            ticket = kayako.new_ticket(
                subject=smart_str(mail.subject),
                fullname="Gigas Support",  # client.id.email,
                email=client.id.email,
                contents=smart_str(mail.message) % {"firstname": smart_str(client.firstname), "license": smart_str(license_key)},
                departmentid="32",
                ticketstatusid="14",
                ticketpriorityid="2",
                tickettypeid="4",
            )

        elif "Plesk" in license_type:
            logging.error("Enters send Plesk Mail")
            mail = get_email_template('license:plesk', client.id)
            if mail is None:
                logging.error("Template license:plesk not found")
            ticket = kayako.new_ticket(
                subject=smart_str(mail.subject) % {"license": smart_str(license)},
                fullname="Gigas Support",  # client.id.email,
                email=client.id.email,
                contents=smart_str(mail.message) % {"firstname": smart_str(client.firstname), "license": smart_str(license)},
                departmentid="32",
                ticketstatusid="10",
                ticketpriorityid="2",
                tickettypeid="4",
            )

        elif "Windows" in license_type:
            logging.error("Enters send Windows Mail")
            mail = get_email_template('license:windows', client.id)
            if mail is None:
                logging.error("Template license:windows not found")
            ticket = kayako.new_ticket(
                subject=smart_str(mail.subject),
                fullname="Gigas Support",  # client.id.email,
                email=client.id.email,
                contents=smart_str(mail.message) % {"firstname": smart_str(client.firstname), "license": smart_str(license)},
                departmentid="32",
                ticketstatusid="14",
                ticketpriorityid="2",
                tickettypeid="4",
            )

        logging.error(ticket)
        logging.error("Acaba envio de ticket")

        try:
            t = etree.fromstring(ticket)

        except etree.XMLSyntaxError:
            logging.error("Error en el parseo del XML de vuelta de envio de ticket")
            resp_text += "Error en el parseo del XML. Pongase en contacto con el responsable de soporte"
            return resp_text

        tick_dict = dict()
        for tick in t.getiterator():
            for elem in tick.getiterator():
                if elem.tag == 'ticketpostid' or elem.tag == 'ticketid':
                    tick_dict[elem.tag] = elem.text

        resp_text += " Ticket Sent"
        logging.error("Ticket Sent")

        #Attach License
        if license_type == "Plesk":
            logging.error("Entra adjunto de Plesk")
            file_name = "plesk_key.xml"
            key_content = str(key['key'])
            license_key = key['license']
        elif license_type == "Windows":
            logging.error("Entra adjunto de Windows")
            file_name = "windows_key.html"
            key_content = smart_str(get_email_template(tplname="winlicticket", client=client.id).message) % {"win_key": str(key)}
            license_key = key
        else:
            file_name = None

        if file_name is not None:
            # Comprimimos la licencia            
            # import StringIO
            # import zipfile
            # zipcontent = StringIO.StringIO()
            # myzipfile = zipfile.ZipFile(zipcontent, mode='w')
            # myzipfile.writestr(file_name, key_content)
            # myzipfile.close()
            # file_name = "license_key.zip"
            # key_content = zipcontent.getvalue()
            # zipcontent.close()

            attachment = kayako.attach_to_ticket(
                tick_dict['ticketid'],
                tick_dict['ticketpostid'],
                file_name,
                key_content)
            logging.error(tick_dict)
            logging.error(attachment)
            logging.error("Acaba el envio de adjunto")

        # Mark license as active
        order_license.status = 'Active'
        order_license.save()

        resp_text += " License: " + license_key
        logging.error("Acaba todo")

        return resp_text


class ClientOptions(object):

    def __init__(self):
        self.fijos = [(0, "Todos")]

    def generar(self):
        tmp = [(c.id, c.fullname()) for c in Client.objects.all()]
        return tmp + self.fijos

    def __iter__(self):
        for choice in self.generar():
            yield choice


class CouponBase(models.Model):
    TYPE = (("fixed", "fixed"),
            ("percent", "percent"))
    CYCLE = (("once", "Once"),
            ("recurring", "Recurring"))
    CLIENTS = (("all", "All customers"),
                ("new", "Only new customers"),
                ("existing", "Only existing customers"))

    code = models.CharField(max_length=32, verbose_name="coupon code")
    value = models.DecimalField(max_digits=10, decimal_places=2,  verbose_name="discount", default=100)
    type_field = models.CharField(max_length=32,
                                  db_column="type", choices=TYPE, verbose_name="discount type", default='percent')
    cycle = models.CharField(max_length=32, choices=CYCLE, verbose_name="discount cycle", default='once')
    products = models.TextField(blank=True)
    upgrades = models.TextField(blank=True)
    addons = models.TextField(blank=True)
    domains = models.TextField(blank=True, null=True)
    cycles = models.CharField(max_length=255, default='all')
    num_usage = models.IntegerField(max_length=5, default=0)
    max_usage = models.IntegerField(max_length=5, default=1)
    expires = models.DateField()
    clients = models.CharField(max_length=255, choices=CLIENTS, verbose_name="Applicable by")
    notes = models.TextField()

    class Meta:
        permissions = (("export_couponbase", "Can export"),)
        abstract = True

    def max_usage_fh(self):
        return 'Unlimited' if self.max_usage == 0 else self.max_usage
    max_usage_fh.short_description = 'Max usage'
    max_usage_fh.admin_order_field = 'max_usage'

    max_usage_custom = property(max_usage_fh)


class Coupon(CouponBase):
    client_id = models.IntegerField(blank=True, null=True, default=0)
    client_id.help_text="Poner 0 para todos o el id de <a href='%s' target='_blank'>cliente</a>" % '../../../clients/client/'  #CLIENT_CHOICES)

    class Meta:
        permissions = (("export_coupon", "Can export"),)
        db_table = 'hb_coupons'

    def __unicode__(self):
        return unicode(self.code)

    def is_used(self):
        return self.num_usage > 0
    is_used.admin_order_field = 'num_usage'

    def get_user(self):
        try:
            user = self.couponlog_set.get().client
            #user = CouponLog.objects.get(coupon__id=self.id).client
        except CouponLog.DoesNotExist:
            user = ""

        return user

    def used_by_link(self):
        try:
            log = self.couponlog_set.get()
            #log = CouponLog.objects.get(coupon__id=self.id)
            client_url = urlresolvers.reverse('admin:clients_client_change', args=(log.client.id,))
            return '<a href="%s">%s</a>' % (client_url, log.client.clientdetail)
        except:
            if self.is_used():
                return 'Unknown'
            else:
                return "--"
    used_by_link.allow_tags = True

    def products_list(self):
        product_ids = self.products.split('|')
        products = []
        for product_id in product_ids:
            try:
                name = Product.objects.get(pk=product_id).name
            except:
                name = 'All'
            products.append(name)
        return ', '.join(products)

    def save(self, *args, **kwargs):
        if not self.clients == 'existing':
            self.client_id.id = 0

        super(Coupon, self).save(*args, **kwargs)

    def creation_date(self):
        try:
            return self.couponextradetail_set.get().creation_date.date()

        except self.DoesNotExist:
            return ''

        except AttributeError:
            return 'Error'

        except:
            return ''

    def assigned_to(self):
        try:
            return self.couponextradetail_set.get().assigned_to

        except self.DoesNotExist:
            return ''

        except AttributeError:
            return 'Error'

        except:
            return ''

    def notes(self):
        try:
            return self.couponextradetail_set.get().notes

        except self.DoesNotExist:
            return ''

        except AttributeError:
            return 'Error'

        except:
            return ''

    def client(self):
        try:
            return self.couponextradetail_set.get().client

        except self.DoesNotExist:
            return ''

        except AttributeError:
            return 'Error'

        except:
            return ''

    def aplicable_by(self):
        if self.clients != 'existing' or self.client_id == 0:
            return self.get_clients_display()
        else:

            c = Client.objects.get(pk=self.client_id_id)
            change_url = urlresolvers.reverse('admin:clients_client_change', args=(c.id,))
            return '<a href="%s">%s</a>' % (change_url, c.email)
    aplicable_by.allow_tags = True

    def resend_coupon(self):
        if self.clients != 'existing' or self.client_id == 0 or self.num_usage>=self.max_usage or(self.expires is not None and self.expires <= datetime.date.today()):
            return ""
        resend_url = urlresolvers.reverse(
            'resend-coupon',
            kwargs={'coupon_id': self.id}
        )
        return '<a href="%s">%s</a>' % (resend_url, "Reenviar")
        # return "Reenviar"
    resend_coupon.allow_tags = True

    def delete(self, *args, **kwargs):
        filterwarnings('ignore', category=Database.Warning)
        super(Coupon, self).delete(*args, **kwargs)

    def extra_type_field(self):
        try:
            return self.couponextradetail_set.get().type_field.promo or '--'
        except (CouponExtraDetail.DoesNotExist, AttributeError):
            return '--'
    extra_type_field.short_description = 'Coupon type'
    extra_type_field.admin_order_field = 'couponextradetail__type_field__promo'

    def referrer_link(self):
        try:
            referrer = self.couponextradetail_set.get().referrer

        except self.couponextradetail_set.model.DoesNotExist:
            pass

        else:
            if referrer is not None:
                change_url = urlresolvers.reverse('admin:clients_client_change',
                                            args=(referrer.id,))
                return '<a href="%s">%s</a>' % (change_url, referrer)

        return '--'

    def all_promos(self):
        return CouponPromo.objects.iterator()

    referrer_link.allow_tags = True
    referrer_link.short_description = 'referrer'
    referrer_link.admin_order_field = 'couponextradetail__referrer__id'

#se usa couponFK para tener un cupon con cliente-foreignkey. como marcamos con un 0 para indicar que es para cualquier cliente, esto hace petar Django. por eso usamos cuponFK
class CouponFK(CouponBase):
    class Meta:
        permissions = (("export_couponfk", "Can export"),)
        db_table = 'hb_coupons'

    client_id = models.ForeignKey(Client, db_column='client_id', unique=False, blank=True)


class CouponPromo(models.Model):
    class Meta:
        permissions = (("export_couponpromo", "Can export"),)
        db_table = 'gigas_promotions'

    promo = models.CharField(max_length=25, primary_key=True)
    description = models.CharField(max_length=50, null=True, blank=False)
    coupon_prefix = models.CharField(max_length=5, null=True, blank=False)
    days_until_action = models.IntegerField(null=True, blank=True, help_text="Optional")
    date_start = models.DateTimeField(null=True, blank=False)
    date_end = models.DateTimeField(null=True, blank=True)
    notes = models.CharField(max_length=250, null=True, blank=False)

    def needs_apply(self):
        return days_until_action is not None

    def validate_unique(self, *args, **kwargs):
        super(CouponPromo, self).validate_unique(*args, **kwargs)

        if self.date_start and self.date_end and self.date_start >= self.date_end:
            raise ValidationError({'date_start' : (u'Date start later than Date end',)})

    def __unicode__(self):
        return unicode(self.promo)


class CouponExtraDetail(models.Model):
    coupon = models.ForeignKey(Coupon, db_column='coupon_id', unique=True)
    creation_date = models.DateField(default=datetime.date.today)
    client = models.CharField(max_length=255, blank=True)
    assigned_to = models.ForeignKey(User)
    notes = models.TextField(blank=True)
    type_field = models.ForeignKey(CouponPromo, db_column='type', null=True, default='trial',help_text='El prefijo de promoción se añadirá al inicio del código de cupón.', verbose_name="Promo")
    referrer = models.ForeignKey(Client, null=True, blank=True, db_column='referer_id')  #TODO: cambiar el nombre en tabla y eliminar db_column

    class Meta:
        permissions = (("export_couponextradetail", "Can export"),)
        db_table = 'gigas_coupons_extradetails'

    def __unicode__(self):
        return unicode(self.coupon)


class CouponLog(models.Model):
    coupon = models.ForeignKey(Coupon)
    client = models.ForeignKey(Client, verbose_name='used by')
    order = models.ForeignKey(Order)
    date = models.DateField(verbose_name='used at')
    discount = models.DecimalField(max_digits=10, decimal_places=2)

    class Meta:
        permissions = (("export_couponlog", "Can export"),)
        db_table = 'hb_coupons_log'

    def __unicode__(self):
        return unicode(self.coupon.code)

    def used_by_link(self):
        try:
            change_url = urlresolvers.reverse('admin:clients_client_change',
                                    args=(self.client.id,))
            return '<a href="%s">%s</a>' % (change_url, self.client)
        except:
            return "--"
    used_by_link.allow_tags = True
    used_by_link.admin_order_field = 'client'
    used_by_link.short_description = 'Used by'

    def coupon_link(self):
        try:
            change_url = urlresolvers.reverse('admin:orders_coupon_change',
                                    args=(self.coupon.id,))
            return '<a href="%s">%s</a>' % (change_url, self.coupon.code)
        except:
            return "--"
    coupon_link.allow_tags = True
    coupon_link.admin_order_field = 'coupon'
    coupon_link.short_description = 'Coupon'

    def order_link(self):
        try:
            change_url = urlresolvers.reverse('admin:orders_order_change',
                                    args=(self.order.id,))
            return '<a href="%s">%s</a>' % (change_url, self.order.id)
        except:
            return '--'
    order_link.allow_tags = True
    order_link.admin_order_field = 'order'
    order_link.short_description = 'order id'


class CouponUsage(CouponLog):
    class Meta:
        permissions = (("export_couponusage", "Can export"),)
        proxy = True

    def referrer_link(self):
        try:
            referrer = self.coupon.couponextradetail_set.get().referrer
            change_url = urlresolvers.reverse('admin:clients_client_change',
                                        args=(referrer.id,))
            return '<a href="%s">%s</a>' % (change_url, referrer)

        except CouponExtraDetail.DoesNotExist:
            return "--"
        except AttributeError:
            return "--"
        except Coupon.DoesNotExist:
            return "--"
        except Order.DoesNotExist:
            return "--"
        except:
            return "--"

    referrer_link.allow_tags = True
    referrer_link.admin_order_field = 'coupon__couponextradetail__referrer__id'
    referrer_link.short_description = 'Referrer'

    def promo_name(self):
        result = ''
        try:
            result = self.coupon.couponextradetail_set.get().type_field.promo
        except:
            result = '--'
        return result
    promo_name.short_description = 'Promo name'

    def status(self):

        try:
            if self.order.invoice_id.status <> 'Paid':
                return "<span style='color:#ff0000;'>Invoice unpaid</span"
        except (Invoice.DoesNotExist, Order.DoesNotExist):
            pass

        try:
            applied = self.couponreferralbenefit
        except CouponReferralBenefit.DoesNotExist:
            applied = False

        days = None
        try:
            days = self.coupon.couponextradetail_set.get().type_field.days_until_action
        except (AttributeError, CouponExtraDetail.DoesNotExist, CouponPromo.DoesNotExist, Coupon.DoesNotExist):
            pass

        referrer = None
        try:
            referrer = self.coupon.couponextradetail_set.get().referrer
        except CouponExtraDetail.DoesNotExist:
            pass

        color = "#000000"
        text = "--"
        if days is None:
            text = '--'
        elif applied:
            color = '#00AA00'
            text = 'Applied on %s' % applied.date
        elif self.date + datetime.timedelta(days=days) > datetime.date.today():
            color = '#999999'
            text = '%s days left' % (self.date + datetime.timedelta(days=days) - datetime.date.today()).days
        else:
            change_url = urlresolvers.reverse('admin:orders_couponusage_change', args=(self.id,))
            return '<button style="color:#CC0000; font-size:0.8em;" onclick="window.location.href=\'%s\'; return false;"> APLICAR </a>' % (change_url)

        return '<strong style="color: %s">%s</strong>' % (color, text)
    status.allow_tags = True


class CouponReferralBenefit(models.Model):
    usage = models.OneToOneField(CouponLog, null=False, blank=False, db_column='coupon_log_id')
    discount = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    date = models.DateField(default=datetime.date.today)

    class Meta:
        permissions = (("export_couponreferralbenefit", "Can export"),)
        db_table = 'gigas_coupon_referral_benefits'

    def __unicode__(self):
        return unicode(self.usage)


class WinLicense(models.Model):
    license_type = models.CharField(max_length=255)
    key = models.CharField(max_length=255)
    count = models.IntegerField(max_length=11)

    class Meta:
        permissions = (("export_winlicense", "Can export"),)
        db_table = 'django_win_licenses'

    def __unicode__(self):
        return unicode(self.id)


class PromoContact(models.Model):
    name = models.CharField(max_length=128)
    company = models.CharField(max_length=128)
    email = models.CharField(max_length=255, blank=True, null=True)
    phone = models.CharField(max_length=24, blank=True, null=True)
    promotype = models.CharField(max_length=24)
    contacted = models.BooleanField()
    referer_name = models.CharField(max_length=128)
    referer_company = models.CharField(max_length=128, blank=True, null=True)
    coupon_id = models.ForeignKey(Coupon, db_column='coupon_id')


    class Meta:
        permissions = (("export_promocontact", "Can export"),)
        db_table = 'gigas_mgmcontact'

    def __unicode__(self):
        return unicode("%s/%s" % (self.name, self.company))

    def mail_repr(self):
        return unicode("Nombre: %s, Empresa: %s, Telefono: %s, Email: %s, Ref. Nombre: %s, Ref. Empresa: %s, Cupon: %s" % (self.name, self.company, self.phone, self.email, self.referer_name, self.referer_company, self.coupon_id.id))


class OrderScenario(models.Model):
    id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=127L)
    
    class Meta:
        permissions = (("export_orderscenario", "Can export"),)
        db_table = 'hb_order_scenarios'
        managed = False

    def __unicode__(self):
        return self.name

    
class OrderScenarioStep(models.Model):
    id = models.AutoField(primary_key=True)
    scenario = models.ForeignKey(OrderScenario, db_column='scenario_id')
    name = models.CharField(max_length=127L)
    auto = models.IntegerField()
    enabled = models.IntegerField()
    class Meta:
        permissions = (("export_orderscenariostep", "Can export"),)
        db_table = 'hb_order_scenarios_steps'
        managed = False

    def __unicode__(self):
        return unicode(self.scenario.id) + u'-' + unicode(self.name)

    
class OrderStep(models.Model):
    STATUS = (('Completed','Completed'), ('Pending','Pending'))
    order =  models.ForeignKey(Order, db_column='order_id', primary_key=True)
    step =   models.ForeignKey(OrderScenarioStep, db_column='step_id', primary_key=True)
    status = models.CharField(max_length=9L, choices=STATUS)
    date_changed = models.DateTimeField(auto_now=True)
    output = models.TextField()

    class Meta:
        permissions = (("export_orderstep", "Can export"),)
        db_table = 'hb_order_steps'
        managed = False
        unique_together = ('order','step',)

    def __unicode__(self):
        return unicode(self.step.name) + u'-' + self.status

